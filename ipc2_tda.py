# -*- coding: utf-8 -*-
"""IPC2-TDA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13SUY55y8rv7aDFn3qkoEq32ZG-WY_LnX
"""

class cliente:
  def __init__(self,nombre,no_habitacion): #con self le digo que esta funcion pertenece a la clase cliente
    self.nombre=nombre   # con esto indico que la clase cliente tiene que tener un nombre y que este valor es el que se le pasa por parametro
    self.no_habitacion=no_habitacion

class node: 
  def __init__(self, cliente=None, next=None): #les coloco none por dado caso no se le pase nada no tire error
    self.cliente=cliente
    self.next=next

class linked_list:  #= lista enlazada (para indicar que me apunte al vacio la primera estructura) 
  def __init__(self):
    self.head = None

  def insertar(self, cliente): #para insertar un cliente a la lista le paso como parametro la clase cliente
    if not self.head: # sino hay ninguna cabecera
      self.head = node(cliente=cliente) #al node solo le paso como parametro el cliente, el next no lo paso porque apunta al vacio 
      return
    current = self.head #current = actual ----- con esto digo que si ya hay cabecera la guarde
    while current.next:# para recorrer la lista y saber quien esta en el final de la lista para insertar otro valor
      current=current.next
    current.next = node(cliente=cliente) # con esto agrego el nuevo valor (ya current esta en el final)  


  def imprimir(self): # para recorrer la lista y saber que elementos tiene
    node = self.head
    while node != None:
      print(node.cliente.nombre, end="=>")  # con esto le digo que nodo vaya a cliente y de cliente me muestre el atributo nombre
      node=node.next

  def eliminar(self, no_habitacion):
    current = self.head
    previous = None

    while current and current.cliente.no_habitacion != no_habitacion: # si tengo cabecera y la habitacion no coincide con las habitaciones
      previous = current
      current = current.next

    if previous is None:
      self.head = current.next
    elif current:
      previous.next=current.next
      current.next = None

c1 = cliente("el man", 101) # creo un objeto de la clase cliente 
c2 = cliente("marco lopez", 103)
c3 = cliente("josue armas", 204)
c4 = cliente("gladys olmos", 302)

lista = linked_list()
lista.insertar(c1)
lista.insertar(c2)
lista.insertar(c3)
lista.insertar(c4)

lista.imprimir()

lista.eliminar(204)

lista.imprimir()



"""LISTAS CIRCULARES

"""

class linked_list_circular:
  def __init__(self, head=None):
    self.head = head
    self.size = 0

  def insertar (self, cliente):
    if self.size == 0:
      self.head = node(cliente = cliente)
      self.head.next = self.head
    else:
      new_node = node(cliente=cliente, next=self.head.next)
      self.head.next = new_node
    self.size += 1 

  def imprimir(self):
    if self.head is None:
      return
    node = self.head
    print(node.cliente.nombre, end = " => ")
    while node.next != self.head:
      node = node.next
      print(node.cliente.nombre, end = " => ")
  
  def eliminar (self, no_habitacion):
    node = self.head
    previous = None

    while True: #no siempre se repite, recorre toda la estructura hasta return
      if node.cliente.no_habitacion == no_habitacion:
        if previous is not None:
          previous.next = node.next
        else:
          while node.next != self.head:
            node = node.next
          node.next = self.head.next
          self.head = self.head.next
        self.size -= 1
        return True
      elif node.next == self.head:
        return False


      previous = node
      node = node.next

"""Inserción"""

lista_c = linked_list_circular()
lista_c.insertar(c1)
lista_c.insertar(c2)
lista_c.insertar(c3)
lista_c.insertar(c4)

"""**Impresión**"""

lista_c.imprimir()

"""**Eliminacion**"""

lista_c.eliminar(101)

lista_c.imprimir()

lista_c.eliminar(103)

lista_c.imprimir()

"""**Listas Doblemente Enlazadas**"""

class node_de:
  def __init__(self, cliente=None, next=None, previous=None):
    self.cliente = cliente
    self.previous = previous
    self.next = next

